



	Algorithm Design And Analysis - MIT OCW
	———————————————————————————————————————

	L-1:	Overview, Interval Scheduling

	L-2:	Divide & Conquer: Convex Hull, Median Finding

	L-3:	Divide & Conquer: FFT

	L-4:	Divide & Conquer: Van Emde Boas Trees

	L-5:	Amortization: Amortized Analysis

	L-6:	Randomization: Matrix Multiply, Quicksort

	L-7:	Randomization: Skip Lists

	L-8:	Randomization: Universal & Perfect Hashing

	L-9:	Augmentation: Range Trees

	L-10:	Dynamic Programming: Advanced DP

	L-11:	Dynamic Programming: All-pairs Shortest Paths

	L-12:	Greedy Algorithms: Minimum Spanning Tree

	L-13:	Incremental Improvement: Max Flow, Min Cut

	L-14:	Incremental Improvement: Matching and Baseball Elimination

	L-15:	Linear Programming: LP, Reductions, Simplex

	L-16:	Complexity: P, NP, NP-completeness, Reductions

	L-17:	Complexity: Approximation Algorithms 

	L-18:	Complexity: Fixed-parameter Algorithms

	L-19:	Synchronous Distributed Algorithms: Symmetry-breaking. Shortest-paths Spanning Trees

	L-20:	Asynchronous Distributed Algorithms: Shortest-paths Spanning Trees

	L-21:	Cryptography: Hash Functions

	L-22:	Cryptography: Encryption

	L-23:	Cache-oblivious Algorithms: Medians & Matrices

	L-24:	Cache-oblivious Algorithms: Searching & Sorting








	Advanced Algorithms - MIT OCW
	—————————————————————————————

	L-1:	Fibonacci Heaps

	L-2:	MST: Persistent Data Structures

	L-3:	Splay Trees-I

	L-4:	Splay Trees-II, Suffix Trees-I, Tries

	L-5:	Suffix Trees-II, Tries, Dial's Algorithm

	L-6:	Dijkstra's Algorithm, Van Emde Boas Queues-I

	L-7:	Van Emde Boas Queues-II, Hashing

	L-8:	2-Level Hashing, Network Flows

	L-9:	Network Flows: Augmenting Paths, Maximum 
	        Augmenting Paths, Scaling	 	 

	L-10:	Reductions between Flow Problems, Bipartite Matching, 
	        Shortest Augmenting Path, Blocking Flows-I

	L-11:	Blocking Flows-II

	L-12:	Min-Cost Flow Algorithms-I

	L-13:	Min-Cost Flow Algorithms-II, Linear Programming-I

	L-14:	Linear Programming-II, Structure of Optima, Weak Duality

	L-15:	Linear Programming-III, Strong Duality

	L-16:	Linear Programming, Complementary Slackness, 
	        Algorithms: Simplex, Ellipsoid
	L-17:	Linear Programming, Algorithms: Interior Point		 	 

	L-18:	Approximation Algorithms, NP-hard problems	 	

	L-19:	4/3-Approximation for TSP	 	 

	L-20:	Relaxations, Directed TSP	 	 

	L-21:	Randomized Rounding, Chernoff Bound, Fixed Parameter 
	        Tractability, Kernelization	

	L-22:	Online Algorithms ie. Ski Rental, Load Balancing, Paging

	L-23:	Randomized Online Algorithms (Adversaries, Fiat's Marking Algorithm, 
	        Potential Functions, Yao's Minimax Principle)	

	L-24:	K-Server Problem, Double-Coverage Algorithm, Computational 
	        Geometry Introduction (Orthogonal Range Search)	

	L-25:	Sweep Algorithms (Convex Hull, Segment Intersection, Voronoi Diagrams)	

	L-26:	Sweep Algorithms (Voronoi Diagrams), Randomized Incremental 
	        Constructions, Backwards Analysis, Linear Programming in 
	        Fixed Dimension	

	L-27:	External Memory Algorithms	

	L-28:	Cache Oblivious Algorithms: Matrix Multiplication, Linked Lists, Median

	L-29:	Cache Oblivious Algorithms: Search Streaming Model

	L-30:	Parallel Algorithms



	Advanced Data Structures - MIT OCW
	——————————————————————————————————

	L-1: Persistent Data Structures

	L-2: Retroactive Data Structures

	L-3: Geometric Structures-I

	L-4: Geometric Structures-II

	L-5: Dynamic Optimality-I

	L-6: Dynamic Optimality-II

	L-7: Memory Hierarchy Models

	L-8: Cache-Oblivious Structures-I

	L-9: Cache-Oblivious Structures-II

	L-10: Dictionaries

	L-11: Integer Models

	L-12: Fusion Trees

	L-13: Integer Lower Bounds

	L-14: Sorting in Linear Time

	L-15: Static Trees

	L-16: Strings

	L-17: Succinct Structures-I

	L-18: Succinct Structures-II

	L-19: Dynamic Graphs-I

	L-20: Dynamic Graphs-II

	L-21: Dynamic Connectivity Lower Bound

	L-22: History of Memory Models







	Distributed Algorithms - MIT OCW
	————————————————————————————————


	L-1:	Course overview. Synchronous networks. Leader 
	        election in synchronous ring networks

	L-2:	Leader election in rings. Basic computational tasks in 
	        general synchronous networks: leader election. Breadth-first search. 
	        Broadcast and convergecast. Shortest paths

	L-3:	Spanning trees. Minimum spanning trees

	L-4:	Fault-tolerant consensus. Link failures: the two generals problem. Process failures (stopping, Byzantine). Algorithms for agreement with stopping and Byzantine failures. Exponential information gathering

	L-5:	Number-of-processor bounds for Byzantine agreement. Weak Byzantine agreement. Time bounds for consensus problems

	L-6:	k-set-agreement. Approximate agreement. Distributed commit

	L-7:	Asynchronous distributed computing. Formal modeling of asynchronous systems using interacting state machines (I/O automata). Proving correctness of distributed algorithms.	

	L-8:	Non-fault-tolerant algorithms for asynchronous networks. Leader election, breadth-first search, shortest paths, broadcast and convergecast.	

	L-9:	Spanning trees. Gallager et al. minimum spanning trees.	

	L-10:	Synchronizers. Synchronizer applications. Synchronous vs. asynchronous distributed systems.	

	L-11:	Time, clocks, and the ordering of events. State-machine simulation. Vector timestamps.	

	L-12:	Stable property detection. Distributed termination. Global snapshots. Deadlock detection.	

	L-13:	Asynchronous shared-memory systems. The mutual exclusion problem. Mutual exclusion algorithms.	
	L-14:	More mutual exclusion algorithms. Bounds on shared memory for mutual exclusion. Resource allocation. The Dining Philosophers problem.	

	L-15:	Shared-memory multiprocessors. Contention, caching, locality. Practical mutual exclusion algorithms. Reading/writing locks.	

	L-16:	Impossibility of consensus in asynchronous, fault-prone, shared-memory systems.	

	L-17:	Atomic objects	

	L-18:	Atomic snapshot algorithms. Atomic read/write register algorithms.	

	L-19:	List algorithms: locking algorithms, optimistic algorithms, lock-free algorithms, lazy 
	algorithms.	

	L-20:	Transactional memory: obstruction-free and lock-based implementations.	

	L-21:	Wait-free computability. The wait-free consensus hierarchy.	

	L-22:	Wait-free vs. f-fault-tolerant atomic objects. Boosting fault-tolerance.	

	L-23:	Asynchronous network model vs. asynchronous shared-memory model. Impossibility of consensus in asynchronous networks. Failure detectors and consensus. Paxos consensus algorithm.	

	L-24:	Self-stabilizing algorithms	

	L-25:	Timing-based systems. Modeling and verification. Timing-based algorithms for mutual exclusion and consensus. Clock synchronization.	





	Udemy 
	—————

	Complexity Theory Basics - Holczer Balazs/Udemy
	Data Structures In Java I - Holczer Balazs/Udemy
	
	Advanced Algorithms In Java I - Holczer Balazs/Udemy
	Algorithms And Data Structures In Java II - Holczer Balazs/Udemy


	Byte-sized-chunks: Stacks, Queues, Binary Trees, Heaps - Udemy 
	Byte-sized-chunks: Graph Algorithms And Problems In Java - Udemy 




	Udacity
	———————

	Intro To Algorithms - Udacity 
	Computability, Complexity And Algorithms - Udacity 





	Algorithms: Design And Analysis - Stanford University/ Coursera
	———————————————————————————————————————————————————————————————

	Algorithms: Design And Analysis I - Stanford University
	Algorithms: Design And Analysis Ii - Stanford University
	Convex Optimization - Stanford University




	Algorithms - Princeton University/Coursera
	——————————————————————————————————————————

	Algorithms Part I - Princeton University/Coursera
	Algorithms Part II - Princeton University/Coursera
	Analysis Of Algorithms - Princeton University/Coursera


	Approximation Algorithms - Ecole Normale Superieure/ Coursera
	———————————————————————————————————————————————————————————————

	Approximation Algorithms Part I (Ecole Normale Superieure) - Coursera
	Approximation Algorithms Part Ii (Ecole Normale Superieure) - Coursera
	Statistical Mechanics: Algorithms And Computations (Ecole Normale Superieure) - Coursera



	Data Structures And Performance - University Of California, San Diego/ Coursera 

	Advanced Modeling For Discrete Optimization - university Of Melbourne/ Coursera



	Algorithms Specialization - Stanford University/ Coursera
	—————————————————————————————————————————————————————————

	Divide And Conquer, Sorting And Searching And Randomizing Algorithms (Stanford University) - Coursera

	Graph Search, Shortest Paths, And Data Structures (Stanford University) - Coursera

	Greedy Algorithms, Minimum Spanning Trees, And Dynamic Programming (Stanford University) - Coursera 

	Shortest Paths Revisited, Np-complete Problems And What To Do About Them (Stanford University) - Coursera


	Data Structures and Algorithms Specialization - UC San Diego/ Coursera
	——————————————————————————————————————————————————————————————————————

	Algorithmic Toolbox (University Of California, San Diego) - Coursera
	Data Structures (University Of California, San Diego) - Coursera
	Algorithms On Graphs (University Of California, San Diego) - Coursera
	Algorithms On Strings (University Of California, San Diego) - Coursera
	Advanced Algorithms And Complexity (University Of California, San Diego) - Coursera
	Genome Assembly Programming Challenge (University Of California, San Diego) - Coursera




	Topoics on Algorithms And Data Structures - Geeks for Geeks
	———————————————————————————————————————————————————————————

		I. Graph algorithms
		————————————————————

				Breadth First Search (BFS)
				Depth First Search (DFS)
				Shortest Path from source to all vertices - Dijkstra
				Shortest Path from every vertex to every other vertex - Floyd Warshall
				Minimum Spanning tree - Prim
				Minimum Spanning tree - Kruskal
				Topological Sort
				Johnson’s algorithm
				Articulation Points (or Cut Vertices) in a Graph
				Bridges in a graph

		II. Dynamic programming
		————————————————————————

				Longest Common Subsequence
				Longest Increasing Subsequence
				Edit Distance
				Minimum Partition
				Ways to Cover a Distance
				Longest Path In Matrix
				Subset Sum Problem
				Optimal Strategy for a Game
				0-1 Knapsack Problem
				Assembly Line Scheduling


		III. Searching and Sorting
		——————————————————————————

				Binary Search
				Quick Sort
				Merge Sort
				Order Statistics
				KMP algorithm
				Rabin karp
				Z’s algorithm
				Aho Corasick String Matching
				Counting Sort
				Manacher’s algorithm


		IV. Number theory and Other Mathematical
		—————————————————————————————————————————

				Primality Test - Introduction and School Method
				Primality Test - Fermat Method)
				Primality Test - Miller–Rabin
				Sieve of Eratosthenes
				Segmented Sieve
				Wilson’s Theorem
				Prime Factorisation
				Pollard’s rho algorithm


		V. Geometrical and Network Flow Algorithms
		———————————————————————————————————————————

				Convex Hull
				Graham Scan
				Line Intersection
				Interval Tree
				Matrix Exponentiation and this
				Maxflow Ford Furkerson Algo and Edmond Karp Implementation
				Min cut
				Stable Marriage Problem
				Hopcroft–Karp Algorithm for Maximum Matching
				Dinic’s algo and e-maxx


		VI. Modulo Arithmetic Algorithms		
		————————————————————————————————

				Basic and Extended Euclidean algorithms
				Euler’s Totient Function
				Modular Exponentiation
				Modular Multiplicative Inverse
				Chinese remainder theorem Introduction
				Chinese remainder theorem and Modulo Inverse Implementation
				nCr%m 


		VII. Data Structures
		————————————————————

				Binary Indexed Tree or Fenwick tree
				Segment Tree (RMQ, Range Sum and Lazy Propagation)
				K-D tree (See insert, minimum and delete)
				Union Find Disjoint Set (Cycle Detection and By Rank and Path Compression)
				Tries
				Suffix array
				Sparse table
				Suffix automata
				Suffix automata II
				LCA and RMQ


Webpage: <http://www.geeksforgeeks.org/top-algorithms-and-data-structures-for-competitive-programming/>














